// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub async fn parse_complete_snapshot_request<B>(
    request: &mut axum::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::CompleteSnapshotInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::complete_snapshot_input::Builder::default();
        let body = request
            .take_body()
            .ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
        let bytes = hyper::body::to_bytes(body).await?;
        if !bytes.is_empty() {
            aws_smithy_http_server::protocols::check_json_content_type(request)?;
            input = crate::json_deser::deser_structure_crate_input_complete_snapshot_input(
                bytes.as_ref(),
                input,
            )?;
        }
        input = input.set_changed_blocks_count(
            crate::http_serde::deser_header_complete_snapshot_complete_snapshot_input_changed_blocks_count(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_checksum(
            crate::http_serde::deser_header_complete_snapshot_complete_snapshot_input_checksum(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_checksum_aggregation_method(
            crate::http_serde::deser_header_complete_snapshot_complete_snapshot_input_checksum_aggregation_method(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_checksum_algorithm(
            crate::http_serde::deser_header_complete_snapshot_complete_snapshot_input_checksum_algorithm(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        lazy_static::lazy_static! {
            static ref RE: regex::Regex = regex::Regex::new("/snapshots/completion/(?P<SnapshotId>[^/]+)").unwrap();
        }
        if let Some(captures) = RE.captures(request.uri().path()) {
            if let Some(m) = captures.name("SnapshotId") {
                input = input.set_snapshot_id(
                    crate::operation_deser::parse_label_complete_snapshot_input_snapshot_id(
                        m.as_str(),
                    )?,
                );
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_snapshot_block_request<B>(
    request: &mut axum::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetSnapshotBlockInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_snapshot_block_input::Builder::default();
        let body = request
            .take_body()
            .ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
        let bytes = hyper::body::to_bytes(body).await?;
        if !bytes.is_empty() {
            aws_smithy_http_server::protocols::check_json_content_type(request)?;
            input = crate::json_deser::deser_structure_crate_input_get_snapshot_block_input(
                bytes.as_ref(),
                input,
            )?;
        }
        lazy_static::lazy_static! {
            static ref RE: regex::Regex = regex::Regex::new("/snapshots/(?P<SnapshotId>[^/]+)/blocks/(?P<BlockIndex>[^/]+)").unwrap();
        }
        if let Some(captures) = RE.captures(request.uri().path()) {
            if let Some(m) = captures.name("BlockIndex") {
                input = input.set_block_index(
                    crate::operation_deser::parse_label_get_snapshot_block_input_block_index(
                        m.as_str(),
                    )?,
                );
            }
            if let Some(m) = captures.name("SnapshotId") {
                input = input.set_snapshot_id(
                    crate::operation_deser::parse_label_get_snapshot_block_input_snapshot_id(
                        m.as_str(),
                    )?,
                );
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_list_changed_blocks_request<B>(
    request: &mut axum::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::ListChangedBlocksInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::list_changed_blocks_input::Builder::default();
        let body = request
            .take_body()
            .ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
        let bytes = hyper::body::to_bytes(body).await?;
        if !bytes.is_empty() {
            aws_smithy_http_server::protocols::check_json_content_type(request)?;
            input = crate::json_deser::deser_structure_crate_input_list_changed_blocks_input(
                bytes.as_ref(),
                input,
            )?;
        }
        lazy_static::lazy_static! {
            static ref RE: regex::Regex = regex::Regex::new("/snapshots/(?P<SecondSnapshotId>[^/]+)/changedblocks").unwrap();
        }
        if let Some(captures) = RE.captures(request.uri().path()) {
            if let Some(m) = captures.name("SecondSnapshotId") {
                input = input.set_second_snapshot_id(
                    crate::operation_deser::parse_label_list_changed_blocks_input_second_snapshot_id(m.as_str())?
                );
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_list_snapshot_blocks_request<B>(
    request: &mut axum::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::ListSnapshotBlocksInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::list_snapshot_blocks_input::Builder::default();
        let body = request
            .take_body()
            .ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
        let bytes = hyper::body::to_bytes(body).await?;
        if !bytes.is_empty() {
            aws_smithy_http_server::protocols::check_json_content_type(request)?;
            input = crate::json_deser::deser_structure_crate_input_list_snapshot_blocks_input(
                bytes.as_ref(),
                input,
            )?;
        }
        lazy_static::lazy_static! {
            static ref RE: regex::Regex = regex::Regex::new("/snapshots/(?P<SnapshotId>[^/]+)/blocks").unwrap();
        }
        if let Some(captures) = RE.captures(request.uri().path()) {
            if let Some(m) = captures.name("SnapshotId") {
                input = input.set_snapshot_id(
                    crate::operation_deser::parse_label_list_snapshot_blocks_input_snapshot_id(
                        m.as_str(),
                    )?,
                );
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_start_snapshot_request<B>(
    request: &mut axum::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::StartSnapshotInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::start_snapshot_input::Builder::default();
        let body = request
            .take_body()
            .ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
        let bytes = hyper::body::to_bytes(body).await?;
        if !bytes.is_empty() {
            aws_smithy_http_server::protocols::check_json_content_type(request)?;
            input = crate::json_deser::deser_structure_crate_input_start_snapshot_input(
                bytes.as_ref(),
                input,
            )?;
        }
        input.build()?
    })
}

pub fn parse_label_complete_snapshot_input_snapshot_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = percent_encoding::percent_decode_str(value).decode_utf8()?;
    Ok(Some(value.into_owned()))
}

pub fn parse_label_get_snapshot_block_input_block_index(
    value: &str,
) -> std::result::Result<std::option::Option<i32>, aws_smithy_http_server::rejection::SmithyRejection>
{
    let value = std::str::FromStr::from_str(value)?;
    Ok(Some(value))
}

pub fn parse_label_get_snapshot_block_input_snapshot_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = percent_encoding::percent_decode_str(value).decode_utf8()?;
    Ok(Some(value.into_owned()))
}

pub fn parse_label_list_changed_blocks_input_second_snapshot_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = percent_encoding::percent_decode_str(value).decode_utf8()?;
    Ok(Some(value.into_owned()))
}

pub fn parse_label_list_snapshot_blocks_input_snapshot_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = percent_encoding::percent_decode_str(value).decode_utf8()?;
    Ok(Some(value.into_owned()))
}
